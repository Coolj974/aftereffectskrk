/************************************************************************
@NAME After-Effects Karaoke Framework
@VERSION 0.55
@AUTHOR pichu
@License LGPL

    This script accompanies Adobe After-Effects CS3 and above

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published 
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    COPYRIGHT (c) 2008 Pichu
    COPYRIGHT (c) 2008 Pichu
	Adobe and After-Effects are the registered trademarks of Adobe Corporation.

@DESCRIPTION
The purpose of this script is to allow users to quickly create karaoke
for their karaoke.  It can be used in writing one script to generate
multiple karaoke.  The javascript prototypes enable users to apply
the karaoke to multiple compoisitions in one run.

@REQUIRE Karaoke_ssa.html: A converter from .ass to javascript object
(JSON) so that you can use it in this script.

To use this as a framework, have a variable defined before including
this script:

var krk = true ;
*************************************************************************/


/*
To import this API into your script, use:

var F = new File( "W:/_Work/ssa_karaoke.jsx" );
if ( F.exists )
{
	F.open( "r" , "TEXT" ) ;
	eval( F.read() )
}

// K is the Karaoke Data generated by Karaoke.html.

*/




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Making a Global Variable within After-Effects, so that they can be called through modules.
var KRK_SYLLABLE = 4,
    KRK_LINE = 3 ;

if ( typeof KRK != 'object' ) { KRK = { } ; }

/**
 * KRK.Common( ) -- Main Karaoke Common Prototype: LEVEL 0
 * @note This prototype contains base functions for all of other prototypes.
 *       This way, no extra codes need to be rewritten.
 */
function KRKCommon( )
{
// Global
	var self = this; 
	/**
	 * resets the children
	 */
	 
	this.children = { } ;
	
	/**
	 * resetting the childrens
	 * ------------------------
	 * note: unique determines if the children are name-object paired.
	 */
	this.reset = function ( )
	{
		self.children[self.childName] = self.unique ? { } : [ ] ;
		return self;
	}
	
	/**
	 * bear -- bear a new child
	 * @param o -- Initializer Object
	 * @param momsName -- override child creation object
	 * @param extraparam -- one extra parameter
	 * @return the new KRK Object
	 */
	this.bear = function( o , extraparam , momsName )
	{
	// Get the chick's name
		if ( !momsName ) { momsName = self.momsName ; }
		
	// If your mate is NO chick, no deal!
		if ( typeof self[momsName] !== 'function' )
		{
			return null ;
		}
	
	// Mating process, yay!
		var obj = new self[momsName]( ) ;
	
	// Obviously a child needs a parent, I think.
		obj.parent = self ;
		
	// Referencing the Karaoke Object
		obj.K = this.K ;

	// Gives the child a set of genes
		obj.constructor( o , extraparam ) ;
		return obj ;
	}
	
	/**
	 * add( object )
	 * @param object -- array, object, scalar of object names or objects
	 * @param extraparam -- extra parameter
	 * @param childName -- child name
	 * @return scalar, array, object of the object type
	 */
	this.add = function( object , extraparam , momsName )
	{
	// Child mom's name
		var c = momsName ? momsName : self.childName ;
		var name , obj ;
		
	// It can be multlets; if there are many children, add them recursively.
		if ( object instanceof Array )
		{
			var o , objects ;
			objects = [ ] ;
			for ( o in object )
			{
				objects[o] = self.add( object[o] , extraparam , c ) ;
			}
			return objects ;
		}
	
	// Bear one child
		else
		{
		// If there are no children, make a womb for them
			if ( ! ( self.children[c] instanceof Array ) && ! ( self.children[c] instanceof Object ) )
			{
				self.reset( ) ;
			}
		
			if ( object instanceof Object )
			{
			// Adopt a child since there's a provider already
				if ( object.caller != undefined )
				{
					return self.children[c][ self.children[c] instanceof Object ? o.name : self.children[c].length ] = 
						object ;
				}
			// Give a child a real name
				name = object.name ;
				obj = object ;
			}
			else
			{
			// Give a child a real name
				name = object ;
				obj = name ;
			}
		
		// Bear a child
			var o = self.bear( obj , c , extraparam ) ;
			
		// Give a shelter for your child
			self.children[c][ self.children[c] instanceof Object ? o.name : self.children[c].length ] = o ;
			return o ;
		}
	}
	
	/**
	 * deletes at least one object
	 * @param object -- an index or the object of the objects
	 * @param number -- number of objects to be deleted
	 * @return
	 */
	this.del = function( object , number , momsName )
	{
		var i ;
		var j = false ;
	
	// The mother whom you remembered you have a child with
		if ( !momsName ) { momsName = self.childName ; }
		
	// Okay, you know which child you want to kick out, but you can't remember where is he.
		if ( object instanceof Object )
		{
		// Go through every single room for the children beared by a certain mother
			for ( i in self.children[momsName] )
			{
			// Since you suck at remembering the names, you finally found out which child it is.
				if ( self.children[momsName][i] == object )
				{
					j = 1 ;
					break ;
				}
			}
			
		// Darn, the child can't be found >_<
			if ( ! j )
			{
				return null ;
			}
		}
		else
		{
		// You know exactly where the child lives in
			i = object ;
		}
		
	// It's the time to kick out the child from your shelter
		var o = self.children[momsName].splice( i , number == undefined ? 1 : number ) ;
		for ( var obj in o )
		{
			delete obj ;
		}
		
	// Next time, remember to use a condom!!!
		return this ;
	}
	
	/**
	 * Get the parent
	 * @param name -- name of the object (KRK[name])
	 * @param object -- object to propagate from (internal)
	 * @return parent
	 */
	this.getParent = function( name , object )
	{
		if ( !object ) { object = self ; }
		if ( object.name !== name )
		{
		// It has no more parent.
			if ( !object.parent )
			{
				return null ;
			}
			return arguments.callee( name , self.parent ) ;
		}
		return object ;
	}
	
	/**
	 * Get the child
	 * @param i -- index of the child
	 * @return the child object
	 */	
	this.getChild = function( i , childName )
	{
		if ( !childName ) { childName = self.childName ; }
		return i == undefined ? this.children[childName] : this.children[childName][i] ;
	}
	
	/**
	 * Get karaoke object
	 * @deprecated
	 */
	this.getKaraObject( )
	{
		return self.K ;
	}
	
	/**
	 * parseLayerName -- parse the layer name
	 * @param name -- After-Effects Layer Name -- format KRK[Style][0][1] 2
	 * @param K -- Karaoke Object (optional)
	 * @return an object of the following form:
	 *         names: type, basedOn, style, layer, line, syl
	 *         line: karaoke line Object
	 *         syl: Karaoke syllable Object
	 */
	this.parseLayerName = function( name , K )
	{
		var line , names ;
		if ( !name )
		{
			name = this.layer.name ;
		}
		else if ( name instanceof Object )
		{
			name = name.name ;
		}		
		if ( a = name.match( /^(.+?)\[\s*(.*?)\s*\]\[\s*(.*?)\s*\]\[\s*(.*?)\s*\](\[\s*(.*?)\s*\])?\s*([^\[\]]*\s*$)/ ) )
		{
			names = { basedOn: a[1], style: a[2], layer: a[3], line: a[4], syl: a[6], extra: a[7] } ;
			if ( K )
			{
				line = K[a[2]][a[3]][a[4]] ;
				kara = a.length < 7 ? null : K[a[2]][a[3]][a[4]][a[6]] ;
			}
		}
		else
		{
			return null ;
		}
		return K ? { names: names , line: line , syl: kara } : names ;
	}

	/**
	 * layer naming
	 * @param title -- title
	 * @param basedOn -- name, based on the layer
	 * @param style -- Karaoke JSON style name
	 * @param layer -- Karaoke JSON layern umber
	 * @param line -- Karao ke JSON line number
	 * @param syl -- Karaoke JSON syllable number
	 * @return
	 */
	this.layerNaming = function( basedOn , style , layer , line , syl , extra )
	{
		if (!self.K) { self.K = self.getKaraObject( ) ; }
		syl = syl == undefined ? "" : " " + syl ;
		return String( basedOn ) + '[' + String( style ) + '][' + String( layer ) + '][' + String( line ) + ']' + ( syl!=undefined && syl != '' && syl!=null ? '[' + String( syl.replace( /\s+/ , '' ) ) + ']' : '' ) + ( extra != undefined ? String(extra) : '' ) ;
	}
	
	/**
	 * originalTimeFunction -- obtains the value
	 * @param value (not used)
	 * @param t time
	 * @param o for options
	 */	
	this.originalTimeFunction = function( t , value , o )
	{
		var that = o['time'] ? o['time'] : this.time ;
		if ( o.unnorm == undefined )
		{
			o.unnorm = that.unnorm ;
		}
		switch ( o.unnorm )
		{
			case "start":
				return t - that.startTime + o.startTime ;
				break;
			case "end":
				return t - that.endTime + o.endTime ;
				break;
			default:
				t = ( t - that.startTime ) / ( that.endTime - that.startTime ) ;
				return t * ( o.endTime - o.startTime ) + o.startTime ;
		}
	}
	
	/**
	 * originalValueFunction -- obtains the value
	 * @param value 
	 * @param t time (not used)
	 * @param o for options
	 */
	this.originaValueFunction = function( t , value , o )
	{
		var mul = o.mul == undefined ? 1 : o.mul ;
		if ( value instanceof Array )
		{
			var opt = [ ] ;
			var start, end ;
			for ( i in value )
			{
				start = o.start == undefined ? 0 : ( o.start instanceof Array ? o.start[i] : o.start ) ;
				end = o.end == undefined ? 1 : ( o.end instanceof Array ? o.end[i] : o.end ) ;
				opt.push( o.unnormValue ? mul * value[i] : ( value[i] * mul * ( end - start ) + start ) );
			}
			return opt ;
		}
		else
		{
				start = o.start == undefined ? 0 : ( o.start instanceof Array ? o.start[0] : o.start ) ;
				end = o.end == undefined ? 1 : ( o.end instanceof Array ? o.end[0] : o.end ) ;
				opt.push( o.unnormValue ? mul * value[0] : ( value[0] * mul * ( end - start ) + start ) );
		}
	}


	/**
	 * Default time function (time is karaoke-time)
	 * @param t -- time
	 * @param value -- value [place holder]
	 * @param o -- an object of this format -- start: starting value, end: ending value,
	 *                                         startTime: starting time, endTime: ending time,
	 *                                         unnorm: "start" unnorm from the start time, "end": unnorm from the end time, default is normalized
	 * @return adjusted time
	 */
	this.defaultTimeFunction = function( t , value , o )
	{
		var that = o['time'] ? o['time'] : this.time 
		if ( o.unnorm == undefined )
		{
			o.unnorm = that.unnorm ;
		}
		switch ( o.unnorm )
		{
			case "start":
				return t + o.startTime - that.startTime ;
				break;
			case "end":
				return t + o.endTime - that.endTime ;
				break;
			default:
				t = ( t - that.startTime ) / ( that.endTime - that.startTime ) ;
				return t * ( o.endTime - o.startTime ) + o.startTime ;
		}
	}

	/**
	 * Default value function
	 * @param t -- time
	 * @param value -- value [place holder]
	 * @param o -- an object of this format -- start: starting value, end: ending value,
	 *                                         startTime: starting time, endTime: ending time,
	 *                                         unnorm: "start" unnorm from the start time, "end": unnorm from the end time, default is normalized
	 * @return adjusted value
	 */
	this.defaultValueFunction = function( t , value , o )
	{
		var mul = o.mul == undefined ? 1 : o.mul ;
		if ( value instanceof Array )
		{
			var opt = [ ] ;
			var start, end ;
			for ( i in value )
			{
				start = o.start == undefined ? 0 : ( o.start instanceof Array ? o.start[i] : o.start ) ;
				end = o.end == undefined ? 1 : ( o.end instanceof Array ? o.end[i] : o.end ) ;
				opt.push( o.unnormValue ? mul * value[i] : ( value[i] * ( end - start ) * mul + start ) );
			}
			return opt ;
		}
		else
		{
			var start = o.start == undefined ? 0 : ( o.start instanceof Array ? o.start[0] : o.start ) ;
			var end = o.end == undefined ? 1 : ( o.end instanceof Array ? o.end[0] : o.end ) ;
			return o.unnormValue ? mul * value : ( value * ( end - start ) * mul + start ) ;
		}
	}


	/**
	 * Get the After-Effects property
	 * @param layer -- After-Effects layer object
	 * @param names -- Array of the names to be propagated through.
	 * @return
	 */
	this.getProperty = function( layer , names )
	{
		var o , i , j , p , name1 , more ;
		o = layer ;
		
	// If it's a list of names
		if ( names instanceof Array )
		{
			for ( i in names )
			{
				if ( p = o.property(names[i]) ) { o = p ; }
			}
		}
		
	// The names are assumed to be properties object
		else if ( names instanceof Object )
		{
			return names ;
		}
		
	// Obtain expressions-like properties
		else
		{
			try
			{
				eval( "if ( p = o." + names + " ) { o = p ; }" )
			}
			catch( err )
			{
				return null ;
			}
		}
		return o ;
	}
	
	/**
	 * sets all the variables in the parent or children to be a value
	 * @param key -- key of the variable
	 * @param value -- value to be set
	 * @param all -- if set, it will set all the children, if not set, it will set the current property
	 *               undefined -- set all children
	 *               null or 'old' -- set the original object
	 *               otherwise -- set the current object
	 */
	this.set = function( key , value , childName )
	{
		var o = !object ? self.children[self.childName] : 
			self.children[childName] ;
		var i;
		for ( i in o )
		{
			o[i][key] = value ;
		}
		return this ;
	}
	
	/**
	 * Set the name of the current object
	 * @param name -- name
	 */
	this.setName = function( name )
	{
		this.name = name ;
		return this ;
	}
	
	/**
	 * Push elements into an array
	 * @param res -- original array
	 * @param res1 -- elements to be pushed
	 * @param name -- (optional) extra one element to be appended
	 * @return res
	 */
	this.pushArray = function( res, res1 , name )
	{
		var o = [ ] ;
		if ( res1 )
		{
			for ( var i in res1 )
			{
				o.push( res1[i] ) ;
			}
		}
		if ( name ) { o.push( name ) ; }
		res.push( o ) ;
		return res; 
	}
	
	/**
	 * recurse through the object with your names
	 * @param object
	 * @param level -- level number (will stop when this level is reached)
	 * @param names: A JSON representation: Example --
	 *               null for everything
	 *               ['romaji'], { romaji: null } for only romaji
	 *               { romaji: [0,1] } for only romaji and Layer #0 and #1
	 *               { romaji: {0: [0,1,2,3:[3,4,5]]} }, etc
	 * @param res (internal -- not set)
	 * @param res1 (internal -- not set)
	 * @return an array list of the names to the object (from level 1 to level level)
	 */
	this.recurseKaraoke = function( level , names )
	{
		var K = this.getKaraObject( ) ;
		var a, b, c, d, e ;
		var na , nb ,nc , nd ;
		var Ka , Kb , Kc , Kd ;
		var pushes = [ ] ;
		if ( !names )
		{
			names = [ ] ;
		}
		else if ( ! ( names instanceof Array ) )
		{
			var n = names.split( /\s*,\s*/ ) ;
			names = n.length < 2 ? [ names ] : n ;
		}
		
		for ( a in names )
		{
			if ( ! ( names[a] instanceof Array ) )
			{
				var n = names[a] ;
				names[a] = {  } ;
				names[a][n] =n  ;
			}
			else
			{
				var n = { } ;
				for ( b in names[a] )
				{
					n[names[a][b]] = names[a][b] ;
				}
				names[a] = n  ;
			}
		}
		var x,y,z,w;
		for ( a in na = names.length < 1 ? K : names[0] )  // Style
		{
			a = a.toLowerCase() ;
			x = names.length < 1 ? a : na[a] ;
			Ka = names.length < 1 ? na[x] : K[x] ;
			for ( b in nb = names.length < 2 ? Ka : names[1] ) // Layer
			{
				y = names.length < 2 ? b : nb[b] ;
				if ( y != Number(y) ) { continue ; }
				Kb = names.length < 2 ? nb[y] : Ka[y] ;
				for ( c in nc = names.length < 3 ? Kb : names[2] ) // Line Number
				{
					z = names.length < 3 ? c : nc[c] ;
					if ( z != Number(z) ) { continue ; }
					Kc = names.length < 3 ? nc[z] : Kb[z] ;
					if ( level == 3 )
					{
						pushes.push( [ x , y , z ] ) ;
						continue ;
					}
					for ( d in nd = names[3] < 4 ? Kc : names[3] ) // Syllable Number
					{
						w = names.length < 4 ? d : nd[d] ;
						if ( w != Number(w) ) { continue ; }
						if ( level >= 4 )
						{
						pushes.push( [ x , y , z , w ] ) ;
							continue ;
						}
					}
				}
			}
			return pushes ;
		}
	}

	/**
	 * objects -- returns a list of objects
	 * @param object -- object
	 * @param names -- an array of array, call from recurseObject
	 * @param level -- the set level
	 * @return an array of objects
	 * @see KRKCommon::recurseObject
	 */
	this.objects = function( object , names , level )
	{
		var name , i , j , o , obj ;
		fobj = [ ] ;
		for ( i in names )
		{
			name = names[i] ;
			if ( level != undefined )
			{
				if ( name.length < level )
				{
					continue ;
				}
			}
			o = object ;
			for ( j in name )
			{
				try{ o = o[name[j]] } catch(err) { break ; }
			}
			obj.push( o ) ;
		}
		return obj ;
	}
	
	/**
	 * addObject -- add a content to the object
	 * @param object -- object
	 * @param key -- an array of keys to be added
	 * @param content -- content to be added
	 * @return object
	 */
	this.addObject = function( object , key , content )
	{
		var i ;
		var k ;
		var o = object ;
		for ( i in key )
		{
			k = key[i] ;
			if ( key.length == i + 1 )
			{
				o[k] = content ;
			}
			else if ( ! ( o[k] instanceof Object ) )
			{
				o[k] = { } ;
			}
			o = o[k] ;
		}
		return object ;
	}
	
	/**
	 * obj - Get an object
	 * @param object
	 * @param arrayKey: an array key, can be from recurseObject
	 * @param level
	 * @see KRKCommon::recurseObject, KRKCommon::objects
	 * @return
	 */
	this.obj = function( object , arrayKey , level )
	{
		var o = object ;
		var key ;
		if ( level == undefined ) { level = 0 ; }
		for ( i in arrayKey )
		{
			key = arrayKey[i] ;
			try { o = o[key] } catch( err ) { return null ; }
			if ( level && i + 1 == level )
			{
				return o ;
			}
		}
		return o ;
	}
	
	/**
	 * reverts to the old state (i.e. this[object] = this.old)
	 */
	this.revert = function( )
	{
		var i ;
		if ( this.old instanceof Object )
		{
			for ( i in this.old )
			{
				this[i] = this.old[i] ;
			}
		}
		else
		{
			this[objectName] = this.old ;
		}
		return this ;
	}
	
	/**
	 * enables the original object
	 * @param all -- true to enable all objects in the pool
	 */
	this.enable = function( all )
	{
		this.set( 'enable' , true , all ) ;
	}

	/**
	 * Disables the original object
	 * @param all -- true to enable all objects in the pool
	 */
	this.disable = function( all )
	{
		this.set( 'enable' , false , all ) ;
	}

	/**
	 * Get an After-Effects Object (KRK BASE)
	 * @param name -- name of the object (can be object, string, or number)
	 * @note if it gives a null or returns an error, it will perform a case-insensitive search until it gets the right name
	 */
	this.getAObject1 = function( name )
	{
		var o ;
		name = name.toLowerCase() ;
		var i = 1;
		do
		{
			try{ o = this[this.objectName][this.caller](i++) } catch( err ) { return null ; }
			if (! ( o instanceof Object ) ) { return null ; }
			if ( o.name ? o.name.toLowerCase( ) == name : false )
			{
				return o ;
			}
		} while ( o ) ;
	}

	this.getAObject = function( name )
	{
		var obj ;
		if ( name instanceof Object )
		{
			this[this.objectName] = name ;
		}
		else
		{
			try
			{
				if ( obj = this[this.objectName][this.caller](name) )
				{
					return obj ;
				}
				else
				{
					return this.getAObject1( name ) ;
				}
			}
			catch( err )
			{
				return this.getAObject1( name ) ;
			}
		}
	return null ;
	}
}

KRK.Common = KRKCommon ;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
